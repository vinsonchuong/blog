<article>
  <header>
    <h1>Combinators over Iterables in ES2015</h1>
    <p>
      Implementing list iteration helpers on top of ES2015 iterables
    </p>
  </header>

  <section>
    <h1>Intro</h1>
    <p>
      My goal is to evaluate the expressiveness of generator functions by
      exploring the set of combinators over generator functions and iterables.
    </p>
  </section>

  <section>
    <h1>Primitives</h1>
    <p>
      Before we can transform and combine iterables, we need functions that can
      produce them:
    </p>
    <code>
      export function* empty() {}

      export function* list(...values) {
        for (const value of values) {
          yield value
        }
      }
    </code>

    <p>
      We can take specific elements of an iterable:
    </p>
    <code>
      export function* head(iterable) {
        for (const value of iterable) {
          yield value;
          break;
        }
      }

      export function* last(iterable) {
        let previousValue;
        for (const value of iterable) {
          previousValue = value;
        }
        yield previousValue;
      }

      export function* tail(iterable) {
        let seenFirstValue = false;
        for (const value of iterable) {
          if (seenFirstValue) {
            yield value;
          } else {
            seenFirstValue = true;
          }
        }
      }

      export function* init(iterable) {
        let previousValue;
        for (const value of iterable) {
          if (!Object.is(previousValue, undefined)) {
            yield previousValue;
          }
          previousValue = value;
        }
      }
    </code>

    <p>
      We can also combine iterables:
    </p>
    <code>
      export function* concat(...iterables) {
        for (const iterable of iterables) {
          yield* iterable;
        }
      }
    </code>
  </section>

  <section>
    <h1>Transforming Iterables</h1>
    <p>
      Now come the standard list iteration functions:
    </p>
    <code>
      export function* map(fn, iterable) {
        for (const value of iterable) {
          yield fn(value);
        }
      }

      export function* filter(fn, iterable) {
        for (const value of iterable) {
          if (fn(value)) {
            yield value;
          }
        }
      }

      export function* fold(fn, initial, iterable) {
        let accumulator = initial;
        for (const value of iterable) {
          accumulator = fn(accumulator, value);
        }
        yield accumulator;
      }

      export function* scan(fn, initial, iterable) {
        let accumulator = initial;
        for (const value of iterable) {
          yield accumulator = fn(accumulator, value);
        }
      }
    </code>
  </section>

  <section>
    <h1>Folds</h1>
    <code>
      export function* all(fn, iterable) {
        yield* fold((acc, val) => acc && val, true, iterable);
      }

      export function* some(fn, iterable) {
        yield* fold((acc, val) => acc || val, false, iterable);
      }

      export function* sum(fn, iterable) {
        yield* fold((acc, val) => acc + val, 0, iterable);
      }

      export function* product(fn, iterable) {
        yield* fold((acc, val) => acc * val, 1, iterable);
      }

      export function* maximum(fn, iterable) {
        yield* fold(Math.max, -Infinity, iterable);
      }

      export function* minimum(fn, iterable) {
        yield* fold(Math.min, +Infinity, iterable);
      }
    </code>
  </section>

  <section>
    <h1>More Complex List Transformations</h1>
    <code>
      export function* intersperse(betweenValue, iterable) {
        yield* head(iterable);
        for (const value of tail(iterable)) {
          yield betweenValue;
          yield value;
        }
      }

      export function* intercalate(betweenIterable, iterable) {
        yield* head(iterable);
        for (const value of tail(iterable)) {
          yield* betweenIterable;
          yield value;
        }
      }

      export function* zip(...iterables) {}
    </code>
  </section>

  <section>
    <h1>Extracting Sublists</h1>
    <code>
      export function* take(n, iterable) {}
      export function* drop(n, iterable) {}

      export function* takeWhile(fn, iterable) {}
      export function* dropWhile(fn, iterable) {}
    </code>
  </section>

  <section>
    <h1>Transducers</h1>
  </section>

  <section>
    <h1>Async Generators</h1>
  </section>

  <section>
    <h1>Push vs. Pull</h1>
  </section>
</article>
